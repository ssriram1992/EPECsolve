<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EPEC solve: Game::NashGame and LCP Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EPEC solve
   </div>
   <div id="projectbrief">Solving Equilibrium Problems with Equilibrium Constraints (EPECs)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classGame_1_1NashGame.html" title="Class to model Nash-cournot games with each player playing a QP. ">Game::NashGame</a> and LCP Example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Before reading this page, please ensure you are aware of the functionalities described in <a class="el" href="QP_Param_Example.html">Game::QP_Param tutorial </a> before following this page.</p>
<p><b>PLAYER</b> <b>1</b>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \min_{q_1}: 10 q_1 + 0.1 q_1^2 - (100 - (q_1+q_2)) q_1 = 1.1 q_1^2 - 90 q_1 + q_1q_2 \]" src="form_52.png"/>
</p>
<p> s.t: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ q_1 &gt;= 0 \]" src="form_53.png"/>
</p>
<p><b>PLAYER</b> <b>2</b>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \min_{q_2}: 5 q_2 + 0.2 q_2^2 - (100 - (q_1+q_2)) q_2 = 1.2 q_2^2 - 95 q_2 + q_2q_1 \]" src="form_54.png"/>
</p>
<p> s.t: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ q_2 &gt;= 0 \]" src="form_55.png"/>
</p>
<p>The above problem corresponds to a <a href="https://en.wikipedia.org/wiki/Cournot_competition">Cournot Competition</a> where the demand curve is given by <img class="formulaInl" alt="$ P = a-BQ $" src="form_57.png"/> where <code>P</code> is the market price and <code>Q</code> is the quantity in the market. The cost of production of both the producers are given by a convex quadratic function in the quantity they produce. The solution to the problem is to find a <a href="https://en.wikipedia.org/wiki/Nash_equilibrium">Nash equilibrium </a> from which neither producer is incentivized to deviate.</p>
<p>To handle this problem, first we create two objects of <a class="el" href="classGame_1_1QP__Param.html" title="Class to handle parameterized quadratic programs(QP) ">Game::QP_Param</a> to model each player's optimization problem, as parameterized by the other. </p><div class="fragment"><div class="line">arma::sp_mat Q(1, 1), A(0, 1), B(0, 1), C(1, 1);</div><div class="line">arma::vec b, c(1);</div><div class="line">b.set_size(0);</div><div class="line"></div><div class="line">Q(0, 0) = 2 * 1.1;</div><div class="line">C(0, 0) = 1;</div><div class="line">c(0) = -90;</div><div class="line"><span class="keyword">auto</span> q1 = std::make_shared&lt;Game::QP_Param&gt;(Q, C, A, B, c, b, &amp;env);</div><div class="line"></div><div class="line">Q(0, 0) = 2 * 1.2;</div><div class="line">c(0) = -95;</div><div class="line"><span class="keyword">auto</span> q2 = std::make_shared&lt;Game::QP_Param&gt;(Q, C, A, B, c, b, &amp;env);</div><div class="line"></div><div class="line">std::vector&lt;shared_ptr&lt;Game::QP_Param&gt;&gt; q{q1, q2}; <span class="comment">// Making a vector shared_ptr to the individual players&#39; problem</span></div></div><!-- fragment --><p>Next, since we do not have any Market clearing constraints, we set empty matrices for them. Note that, if the problem does not have market clearing constraints, still the matrices have to be input with zero rows and appropriate number of columns. </p><div class="fragment"><div class="line">sp_mat MC(0, 2);</div><div class="line">vec MCRHS;</div><div class="line">MCRHS.set_size(0);</div></div><!-- fragment --><p> Finally now, we can make the <a class="el" href="classGame_1_1NashGame.html" title="Class to model Nash-cournot games with each player playing a QP. ">Game::NashGame</a> object by invoking the constructor.</p>
<div class="fragment"><div class="line">GRBEnv env;</div><div class="line"><a class="code" href="classGame_1_1NashGame.html">Game::NashGame</a> Nash = <a class="code" href="classGame_1_1NashGame.html">Game::NashGame</a>(&amp;env, q, MC, MCRHS);</div></div><!-- fragment --><p>Using traditional means, one can write a linear complementarity problem (LCP) to solve the above problem. The LCP is given as follows.</p>
<p><b> EXPECTED LCP </b> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} 0 \le q_1 \perp 2.2 q_1 + q_2 - 90 \geq 0\\ 0 \le q_2 \perp q_1 + 2.4 q_2 - 95 \geq 0 \end{eqnarray*}" src="form_59.png"/>
</p>
<p>To observe the LCP formulation of this NashGame, one can use <a class="el" href="classGame_1_1NashGame.html#a14d6e14edc240c043cf69434a2731e96">Game::NashGame::FormulateLCP</a> member function. </p><div class="fragment"><div class="line">arma::sp_mat M;</div><div class="line">arma::vec q;</div><div class="line"><a class="code" href="epecsolve_8h.html#ad87785d9eb3e6e48c0895b348f6660ca">perps</a> Compl;        <span class="comment">// Stores the complementarity pairs relationships.</span></div><div class="line">Nash.<a class="code" href="classGame_1_1NashGame.html#a14d6e14edc240c043cf69434a2731e96">FormulateLCP</a>(M, q, Compl); <span class="comment">// Compute the LCP</span></div><div class="line"></div><div class="line">M.print();</div><div class="line">q.print(); </div></div><!-- fragment --><p>Here <code>M</code> and <code>q</code> are such that the solution to the LCP <img class="formulaInl" alt="$ 0 \le x \perp Mx + q \ge 0 $" src="form_62.png"/> solves the original NashGame. These matrices can be written to a file and solved externally now.</p>
<p>Alternatively, one can pass it to the <a class="el" href="classGame_1_1LCP.html" title="Class to handle and solve linear complementarity problems. ">Game::LCP</a> class, and solve it natively. To achieve this, one can pass the above matrices to the constructor of the <a class="el" href="classGame_1_1LCP.html" title="Class to handle and solve linear complementarity problems. ">Game::LCP</a> class. </p><div class="fragment"><div class="line">GRBEnv env = GRBEnv();</div><div class="line"><a class="code" href="classGame_1_1LCP.html">Game::LCP</a> lcp = <a class="code" href="classGame_1_1LCP.html">Game::LCP</a>(&amp;env, M, q, 1, 0);</div></div><!-- fragment --><p>More concisely, the class <a class="el" href="classGame_1_1LCP.html" title="Class to handle and solve linear complementarity problems. ">Game::LCP</a> offers a constructor with the NashGame itself as an argument. This way, one need not explicitly compute <code>M</code>, <code>q</code> etc., to create the <a class="el" href="classGame_1_1LCP.html" title="Class to handle and solve linear complementarity problems. ">Game::LCP</a> object. </p><div class="fragment"><div class="line"><a class="code" href="classGame_1_1LCP.html">Game::LCP</a> lcp2 = <a class="code" href="classGame_1_1LCP.html">Game::LCP</a>(&amp;env, Nash);</div></div><!-- fragment --><p>Now the <a class="el" href="classGame_1_1LCP.html" title="Class to handle and solve linear complementarity problems. ">Game::LCP</a> object can be solved. And indeed the solution helps obtain the Nash equilibrium of the original Nash game. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> model = lcp.<a class="code" href="classGame_1_1LCP.html#a6ff524eb77ff44492107f0863fe1ed00">LCPasMIP</a>();</div><div class="line">model.optimize();          </div><div class="line"><span class="comment">// Alternatively, auto model = lcp.LCPasMIP(true); will already optimize and solve the model.</span></div></div><!-- fragment --><p> As was the case with <a class="el" href="classGame_1_1QP__Param.html#a94c1b94ff3a3423dfcec43f2d66e3507">Game::QP_Param::solveFixed</a>, the above function returns a unique_ptr to GRBModel. And all native operations to the GRBModel can be performed and the solution be obtained.</p>
<p>The solution to this problem can be obtained as <img class="formulaInl" alt="$q_1=28.271028$" src="form_71.png"/>, <img class="formulaInl" alt="$q_2=27.803728$" src="form_72.png"/>. To indeed check that this solution is correct, one can create a solution vector and solve each player's <a class="el" href="classGame_1_1QP__Param.html" title="Class to handle parameterized quadratic programs(QP) ">Game::QP_Param</a> and check that the solution indeed matches. </p><div class="fragment"><div class="line">arma::vec Nashsol(2);</div><div class="line">Nashsol(0) = model-&gt;getVarByName(<span class="stringliteral">&quot;x_0&quot;</span>).get(GRB_DoubleAttr_X); <span class="comment">// This is 28.271028 </span></div><div class="line">Nashsol(1) = model-&gt;getVarByName(<span class="stringliteral">&quot;x_1&quot;</span>).get(GRB_DoubleAttr_X); <span class="comment">// This is 27.803728</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> nashResp1 = Nash.<a class="code" href="classGame_1_1NashGame.html#a3f8b9352623a4c15d8186382027461b9">Respond</a>(0, Nashsol);</div><div class="line"><span class="keyword">auto</span> nashResp2 = Nash.<a class="code" href="classGame_1_1NashGame.html#a3f8b9352623a4c15d8186382027461b9">Respond</a>(1, Nashsol);</div><div class="line"></div><div class="line">cout&lt;&lt;nashResp1-&gt;getVarByName(<span class="stringliteral">&quot;y_0&quot;</span>).get(GRB_DoubleAttr_X)&lt;&lt;endl; <span class="comment">// Should print 28.271028</span></div><div class="line">cout&lt;&lt;nashResp2-&gt;getVarByName(<span class="stringliteral">&quot;y_0&quot;</span>).get(GRB_DoubleAttr_X)&lt;&lt;endl; <span class="comment">// Should print 27.803728</span></div></div><!-- fragment --><p> One can, thus check that the values match the solution values obtained earlier. If only does not want the individual GRBModel handles, but just want to confirm either that the problem is solved or to provide a player with profitable deviation, one can just use <a class="el" href="classGame_1_1NashGame.html#a28ff99cbe8f408add01afcbda9249934">Game::NashGame::isSolved</a> function as follows. </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> temp1 ; arma::vec temp2;</div><div class="line">cout&lt;&lt;Nash.<a class="code" href="classGame_1_1NashGame.html#a28ff99cbe8f408add01afcbda9249934">isSolved</a>(Nashsol, temp1, temp2); <span class="comment">// This should be true.</span></div></div><!-- fragment --><p> If the <a class="el" href="classGame_1_1NashGame.html#a28ff99cbe8f408add01afcbda9249934">Game::NashGame::isSolved</a> function returns false, then <code>temp1</code> and <code>temp2</code> respectively contain the player with profitable deviation, and the more profitable strategy of the player.</p>
<p>And note that, just like <a class="el" href="classGame_1_1QP__Param.html" title="Class to handle parameterized quadratic programs(QP) ">Game::QP_Param</a>, <a class="el" href="classGame_1_1NashGame.html" title="Class to model Nash-cournot games with each player playing a QP. ">Game::NashGame</a> can also be saved to and loaded from an external file. </p><div class="fragment"><div class="line">Nash.<a class="code" href="classGame_1_1NashGame.html#a3e3fef23622c1c031b9f4e43a1a42a16">save</a>(<span class="stringliteral">&quot;dat/Nash.dat&quot;</span>); <span class="comment">//Saves the object</span></div><div class="line"><a class="code" href="classGame_1_1NashGame.html">Game::NashGame</a> Nash2(&amp;env);</div><div class="line">Nash2.load(<span class="stringliteral">&quot;dat/Nash.dat&quot;</span>); <span class="comment">// Loads the object into memory.</span></div></div><!-- fragment --><p> Now that you are aware of most of the functionalities of <a class="el" href="classGame_1_1NashGame.html" title="Class to model Nash-cournot games with each player playing a QP. ">Game::NashGame</a>, let us switch to the next tutorial on <a class="el" href="LCP_Example.html">LCP </a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
