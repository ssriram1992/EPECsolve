<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EPEC solve: Game::EPEC Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EPEC solve
   </div>
   <div id="projectbrief">Solving Equilibrium Problems with Equilibrium Constraints (EPECs)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classGame_1_1EPEC.html" title="Class to handle a Nash game between leaders of Stackelberg games. ">Game::EPEC</a> Example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Consider the following problem: The first player is the u-v player, where the leader's decision variables are <img class="formulaInl" alt="$u$" src="form_80.png"/> and the follower's decision variaables are <img class="formulaInl" alt="$v$" src="form_81.png"/>. The second player is the x-y player where the leader's and the follower's variables are <img class="formulaInl" alt="$x$" src="form_5.png"/> and <img class="formulaInl" alt="$y$" src="form_82.png"/> respectively.</p>
<dl class="section user"><dt>u-v player</dt><dd>The u-v player's optimization problem is given below <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} min_{u,v} \quad&amp;:\quad v_1 -u + y_1v_2&amp;\qquad \text{s.t.}\\ u \quad&amp;\ge\quad 0\\ v_1+v_2+u \quad&amp;\leq\quad 5\\ v \quad&amp;\in\quad \arg \min _v \left \{ -v_1+v_2 : v \ge 0; 2v_1+v_2 \leq u; v_1 -2v_2 \leq -u \right \} \end{align*}" src="form_105.png"/>
</p>
</dd></dl>
<dl class="section user"><dt>x-y player</dt><dd>On a similar note, the optimization problem of the x-y player is given as follows. <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \min_{x,y} \quad&amp;:\quad y_1 - x + uy_2&amp;\qquad \text{s.t.}\\ x \quad&amp;\ge\quad 0\\ y_1 + y_2 + x \quad&amp;\le\quad 7\\ -y_1 + y_2 \quad&amp;\le\quad 0\\ y\quad&amp;\in\quad\arg\min_y \left\{ y_1 - y_2: y \ge 0; -y_1 + y_2 \le 5-x; -y_1 + y_2 \le x-3 \right\} \end{align*}" src="form_106.png"/>
</p>
</dd></dl>
<dl class="section user"><dt>Nash equilibrium</dt><dd>The problem has a pure-strategy Nash equilibrium given by <img class="formulaInl" alt="$ (u, v_1, v_2) = (2.78, 0.56, 1.67) $" src="form_107.png"/> and <img class="formulaInl" alt="$ (x, y_1, y_2) = (1.67, 1.33, 0) $" src="form_108.png"/></dd></dl>
<dl class="section user"><dt>MODELING THE PROBLEM</dt><dd></dd></dl>
<p><b> Step 1. </b> The first step in modeling a game between Stackelberg leaders is to include <a class="el" href="epecsolve_8h.html">epecsolve.h</a> and create a derived class of <a class="el" href="classGame_1_1EPEC.html" title="Class to handle a Nash game between leaders of Stackelberg games. ">Game::EPEC</a>. The minimal constructor for <a class="el" href="classGame_1_1EPEC.html" title="Class to handle a Nash game between leaders of Stackelberg games. ">Game::EPEC</a> involves passing a pointer to GRBEnv (Check Gurobi's C++ reference manual to understand what a GRBEnv is.). The derived class should indeed instantiate the base class (<a class="el" href="classGame_1_1EPEC.html" title="Class to handle a Nash game between leaders of Stackelberg games. ">Game::EPEC</a>) using such a constructor. The code below, achieves it. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="epecsolve_8h.html">epecsolve.h</a>&quot;</span></div><div class="line"><span class="keyword">class </span>my_Prob : <span class="keyword">public</span> <a class="code" href="classGame_1_1EPEC.html">Game::EPEC</a></div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        my_Prob(GRBEnv *e) : <a class="code" href="namespaceGame.html">Game</a>::EPEC(e) {}</div><div class="line">};</div></div><!-- fragment --><p><b> Step 2. </b> Next, we should define the lower level of each leader (u-v leader as well as the x-y leader) as a <a class="el" href="classGame_1_1NashGame.html" title="Class to model Nash-cournot games with each player playing a QP. ">Game::NashGame</a> object. For convenience, we write the following two functions that return a <code>std::sharedptr&lt;Game::NashGame&gt;</code>. Note that</p>
<ul>
<li>The referred object contains the follower's game along with any constraint in the leader level.</li>
<li>The referred object does not contain the follower's objective (which could potentiall depend upon other leaders' variables).</li>
<li>We create the object, <em> without </em> assuming the presence of other leaders.</li>
</ul>
<p>The following code returns the <code>std::shareptr&lt;&gt;</code> as required. To refresh the concepts about creating a <a class="el" href="classGame_1_1NashGame.html" title="Class to model Nash-cournot games with each player playing a QP. ">Game::NashGame</a> object, refer to <a class="el" href="NashGame_Example.html">Game::NashGame tutorial </a>. </p><div class="fragment"><div class="line">std::shared_ptr&lt;Game::NashGame&gt; <a class="code" href="example_8cpp.html#a8c14f00b24da0f390b1fd45aaae2fdda">uv_leader</a>(GRBEnv *env) {</div><div class="line">  <span class="comment">// 2 variable and 2 constraints</span></div><div class="line">  arma::sp_mat Q(2, 2), C(2, 1), A(2, 1), B(2, 2);</div><div class="line">  arma::vec c(2, arma::fill::zeros);</div><div class="line">  arma::vec b(2, arma::fill::zeros);</div><div class="line">  <span class="comment">// Q remains as 0</span></div><div class="line">  <span class="comment">// C remains as 0</span></div><div class="line">  <span class="comment">// c</span></div><div class="line">  c(0) = -1;</div><div class="line">  c(1) = 1;</div><div class="line">  <span class="comment">// A</span></div><div class="line">  A(0, 0) = -1;</div><div class="line">  A(1, 0) = 1;</div><div class="line">  <span class="comment">// B</span></div><div class="line">  B(0, 0) = 2;</div><div class="line">  B(0, 1) = 1;</div><div class="line">  B(1, 0) = 1;</div><div class="line">  B(1, 1) = -2;</div><div class="line">  <span class="keyword">auto</span> foll = std::make_shared&lt;Game::QP_Param&gt;(Q, C, A, B, c, b, env);</div><div class="line"></div><div class="line">  <span class="comment">// Lower level Market clearing constraints - empty</span></div><div class="line">  arma::sp_mat MC(0, 3);</div><div class="line">  arma::vec MCRHS(0, arma::fill::zeros);</div><div class="line"></div><div class="line">  arma::sp_mat LeadCons(1, 3);</div><div class="line">  arma::vec LeadRHS(1);</div><div class="line">  LeadCons(0, 0) = 1;</div><div class="line">  LeadCons(0, 1) = 1;</div><div class="line">  LeadCons(0, 2) = 1;</div><div class="line">  LeadRHS(0) = 5;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> N = std::make_shared&lt;Game::NashGame&gt;(</div><div class="line">      env, std::vector&lt;std::shared_ptr&lt;Game::QP_Param&gt;&gt;{foll}, MC, MCRHS, 1,</div><div class="line">      LeadCons, LeadRHS);</div><div class="line">  <span class="keywordflow">return</span> N;</div><div class="line">}</div></div><!-- fragment --><p> And we have a similar function for the x-y leader. </p><div class="fragment"><div class="line">std::shared_ptr&lt;Game::NashGame&gt; <a class="code" href="example_8cpp.html#ace379e899ab4b800e81aadcc80d42922">xy_leader</a>(GRBEnv *env) {</div><div class="line">  <span class="comment">// 2 variable and 2 constraints</span></div><div class="line">  arma::sp_mat Q(2, 2), C(2, 1), A(2, 1), B(2, 2);</div><div class="line">  arma::vec c(2, arma::fill::zeros);</div><div class="line">  arma::vec b(2, arma::fill::zeros);</div><div class="line">  <span class="comment">// Q remains as 0</span></div><div class="line">  <span class="comment">// C remains as 0</span></div><div class="line">  <span class="comment">// c</span></div><div class="line">  c(0) = 1;</div><div class="line">  c(1) = -1;</div><div class="line">  <span class="comment">// A</span></div><div class="line">  A(0, 0) = 1;</div><div class="line">  A(1, 0) = -1;</div><div class="line">  <span class="comment">// B</span></div><div class="line">  B(0, 0) = -1;</div><div class="line">  B(0, 1) = 1;</div><div class="line">  B(1, 0) = -1;</div><div class="line">  B(1, 1) = 1;</div><div class="line">  <span class="comment">// b</span></div><div class="line">  b(0) = 5;</div><div class="line">  b(1) = -3;</div><div class="line">  <span class="keyword">auto</span> foll = std::make_shared&lt;Game::QP_Param&gt;(Q, C, A, B, c, b, env);</div><div class="line"></div><div class="line">  <span class="comment">// Lower level Market clearing constraints - empty</span></div><div class="line">  arma::sp_mat MC(0, 3);</div><div class="line">  arma::vec MCRHS(0, arma::fill::zeros);</div><div class="line"></div><div class="line">  arma::sp_mat LeadCons(2, 3);</div><div class="line">  arma::vec LeadRHS(2);</div><div class="line">  LeadCons(0, 0) = 1;</div><div class="line">  LeadCons(0, 1) = 1;</div><div class="line">  LeadCons(0, 2) = 1;</div><div class="line">  LeadRHS(0) = 7;</div><div class="line">  <span class="comment">// Comment the following four lines for another example ;)</span></div><div class="line">  LeadCons(1, 0) = -1;</div><div class="line">  LeadCons(1, 1) = 1;</div><div class="line">  LeadCons(1, 2) = 0;</div><div class="line">  LeadRHS(1) = 0;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> N = std::make_shared&lt;Game::NashGame&gt;(</div><div class="line">      env, std::vector&lt;std::shared_ptr&lt;Game::QP_Param&gt;&gt;{foll}, MC, MCRHS, 1,</div><div class="line">      LeadCons, LeadRHS);</div><div class="line">  <span class="keywordflow">return</span> N;</div><div class="line">}</div></div><!-- fragment --><p>We also use a member function to add these leaders to the class. The following code achieves this. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classMy__EPEC__Prob.html#ac6ab1a1debfe0fe9070d270388a18348">My_EPEC_Prob::addLeader</a>(std::shared_ptr&lt;Game::NashGame&gt; N, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i) {</div><div class="line">  this-&gt;<a class="code" href="classGame_1_1EPEC.html#aab21e947c4fc518c305d7c35a8407f64">countries_LL</a>.push_back(N);</div><div class="line">  <a class="code" href="classMy__EPEC__Prob.html#af7de4840143d26c53b7ead389ff015e2">ends</a>[i] = N-&gt;getNprimals() + N-&gt;getNleaderVars();</div><div class="line">  this-&gt;<a class="code" href="classGame_1_1EPEC.html#a618f3df2c40a9d456f9ceaf00802967c">LocEnds</a>.push_back(&amp;<a class="code" href="classMy__EPEC__Prob.html#af7de4840143d26c53b7ead389ff015e2">ends</a>[i]);</div><div class="line">}</div></div><!-- fragment --><p> Note that the above code achieves the following key ideas, which must always be taken care of while adding leaders to a problem.</p>
<ul>
<li>The lower-level <a class="el" href="classGame_1_1NashGame.html" title="Class to model Nash-cournot games with each player playing a QP. ">Game::NashGame</a> is pushed to <a class="el" href="classGame_1_1EPEC.html#aab21e947c4fc518c305d7c35a8407f64">Game::EPEC::countries_LL</a>.</li>
<li>Variables that track the number of variables in the current leader (<code>ends</code>[i]) is set and is tracked by <a class="el" href="classGame_1_1EPEC.html#a618f3df2c40a9d456f9ceaf00802967c">Game::EPEC::LocEnds</a> at the appropriate position.</li>
</ul>
<p><b> Step 3. </b> <a class="el" href="classGame_1_1EPEC.html" title="Class to handle a Nash game between leaders of Stackelberg games. ">Game::EPEC</a> is a pure virtual (abstract) class and it is mandatory to define two functions by every derived class that it has. First, we define <a class="el" href="classGame_1_1EPEC.html#a50bab61e0943dc5cc730ae660bba2605" title="Can be instantiated by a derived class only! ">Game::EPEC::make_obj_leader</a>. This function has the following signature in its definition in <a class="el" href="classGame_1_1EPEC.html" title="Class to handle a Nash game between leaders of Stackelberg games. ">Game::EPEC</a>. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> make_obj_leader(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, <a class="code" href="structGame_1_1QP__objective.html">Game::QP_objective</a> &amp;QP_obj) = 0;</div></div><!-- fragment --><p> The parameter <code>i</code> take the position of the leader and <code>QP_obj</code> is an out-parameter, which should be filled with an object of <a class="el" href="structGame_1_1QP__objective.html" title="struct to handle the objective params of MP_Param/QP_Param ">Game::QP_objective</a>, which has the i-th leader's objective. Note that this should assume the form <img class="formulaInl" alt="$ c^Tx + (Cx)^Tx^{oth} $" src="form_109.png"/> where <img class="formulaInl" alt="$ x $" src="form_110.png"/> is the current player's set of variables and <img class="formulaInl" alt="$x^{oth} $" src="form_111.png"/> is the remaining set of variables. The definition of this function is shown below. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_Prob::make_obj_leader(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, <a class="code" href="structGame_1_1QP__objective.html">Game::QP_objective</a> &amp;QP_obj)<span class="keyword"> override </span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    QP_obj.<a class="code" href="structGame_1_1QP__objective.html#a18c0eadf5706175777a16f2d9349f539">Q</a>.zeros(3, 3);</div><div class="line">    QP_obj.<a class="code" href="structGame_1_1QP__objective.html#add2d1d53d0a2b14e047b5ff87fe86859">C</a>.zeros(3, 3);</div><div class="line">    QP_obj.<a class="code" href="structGame_1_1QP__objective.html#aace376a44fea80a8fbe5eb712e14b3e5">c</a>.zeros(3);</div><div class="line">    <span class="keywordflow">switch</span> (i) </div><div class="line">    {</div><div class="line">    <span class="keywordflow">case</span> 0: <span class="comment">// uv_leader&#39;s objective</span></div><div class="line">      QP_obj.<a class="code" href="structGame_1_1QP__objective.html#add2d1d53d0a2b14e047b5ff87fe86859">C</a>(1, 0) = 1;</div><div class="line">      QP_obj.<a class="code" href="structGame_1_1QP__objective.html#aace376a44fea80a8fbe5eb712e14b3e5">c</a>(0) = 1;</div><div class="line">      QP_obj.<a class="code" href="structGame_1_1QP__objective.html#aace376a44fea80a8fbe5eb712e14b3e5">c</a>(2) = -1;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> 1: <span class="comment">// xy_leader&#39;s objective</span></div><div class="line">      QP_obj.<a class="code" href="structGame_1_1QP__objective.html#add2d1d53d0a2b14e047b5ff87fe86859">C</a>(1, 2) = 1;</div><div class="line">      QP_obj.<a class="code" href="structGame_1_1QP__objective.html#aace376a44fea80a8fbe5eb712e14b3e5">c</a>(0) = 1;</div><div class="line">      QP_obj.<a class="code" href="structGame_1_1QP__objective.html#aace376a44fea80a8fbe5eb712e14b3e5">c</a>(2) = 1;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">default</span>: <span class="comment">// Not strictly required, but for safety</span></div><div class="line">      <span class="keywordflow">throw</span> std::string(<span class="stringliteral">&quot;Invalid make_obj_leader&quot;</span>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><b> Step 4. </b> Finally, another function <a class="el" href="classGame_1_1EPEC.html#a5b83a88a92c6b8cd9a4570f2e7ab849e">Game::EPEC::updateLocs</a> has to be redefined necessarily too. For small, toy examples, this function can only update the location of the last variable as the total number of variables defined by the user plus any convex hull variables. But, for more complicated examples, we refer the user to check <a class="el" href="classModels_1_1EPEC.html#a9313bc508f5ca2b2aad9a7093d6e3e78">Models::EPEC::updateLocs</a>. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classMy__EPEC__Prob.html#a86c301b16593d38339cbbd4a8cf68493">My_EPEC_Prob::updateLocs</a>()<span class="keyword"> override </span>{</div><div class="line">  <a class="code" href="classMy__EPEC__Prob.html#af7de4840143d26c53b7ead389ff015e2">ends</a>[0] = this-&gt;<a class="code" href="classGame_1_1EPEC.html#a0ae85cba915c2cfcdfd8b141e2daffbe">convexHullVariables</a>.at(0) + 3;</div><div class="line">  <a class="code" href="classMy__EPEC__Prob.html#af7de4840143d26c53b7ead389ff015e2">ends</a>[1] = this-&gt;<a class="code" href="classGame_1_1EPEC.html#a0ae85cba915c2cfcdfd8b141e2daffbe">convexHullVariables</a>.at(1) + 3;</div><div class="line">}</div></div><!-- fragment --><p><b> Step 5. </b> Now that the derived class is ready, the EPEC can be solved using an instantiation of the class. We lead you through the corresponding code, below.</p>
<p>To start, with set up a Gurobi environment like we did for <a class="el" href="classGame_1_1QP__Param.html" title="Class to handle parameterized quadratic programs(QP) ">Game::QP_Param</a> and <a class="el" href="classGame_1_1NashGame.html" title="Class to model Nash-cournot games with each player playing a QP. ">Game::NashGame</a>. </p><div class="fragment"><div class="line">GRBEnv env;</div></div><!-- fragment --><p>The code is meant to produce various levels of logs. High levels of logging can produce numerous verbose messages that are meant only for debugging while low levels of logging might produce no output at all, till the program terminates failing to give any update on how the algorithm is performing. We use Boost logging (<a href="https://www.boost.org/doc/libs/1_70_0/libs/log/doc/html/index.html">See documentation</a>) for handling the logging. You can choose your favorite logging level between</p>
<ul>
<li>trace</li>
<li>debug</li>
<li>info</li>
<li>warning</li>
<li>error</li>
<li>fatal</li>
</ul>
<p>We suggest a log level of <code>info</code> and higher, using the following code. Not setting the log level gives the highest verbosity (i.e., automatically sets it to <code>trace</code> level). </p><div class="fragment"><div class="line">boost::log::core::get()-&gt;set_filter(boost::log::trivial::severity &gt;= boost::log::trivial::info);</div></div><!-- fragment --><p>Next, we create an object for the class and add both the lower level <a class="el" href="classGame_1_1NashGame.html" title="Class to model Nash-cournot games with each player playing a QP. ">Game::NashGame</a> using functions defined earlier. </p><div class="fragment"><div class="line"><span class="comment">// Create the class object</span></div><div class="line"><a class="code" href="classMy__EPEC__Prob.html">My_EPEC_Prob</a> epec(&amp;env);</div><div class="line"><span class="comment">// Adding uv_leader</span></div><div class="line"><span class="keyword">auto</span> uv_lead = <a class="code" href="example_8cpp.html#a8c14f00b24da0f390b1fd45aaae2fdda">uv_leader</a>(&amp;env);</div><div class="line">epec.addLeader(uv_lead, 0);</div><div class="line"><span class="comment">// Adding xy_leader</span></div><div class="line"><span class="keyword">auto</span> xy_lead = <a class="code" href="example_8cpp.html#ace379e899ab4b800e81aadcc80d42922">xy_leader</a>(&amp;env);</div><div class="line">epec.addLeader(xy_lead, 1);</div></div><!-- fragment --><p>Once all the leaders' lower levels are added, we tell the program that we are adding no more players, and the code can do certain pre-processing and space allocation using <a class="el" href="classGame_1_1EPEC.html#ab32d89068adc66f100a266bbf31bf63e" title="Finalizes the creation of a Game::EPEC object. ">Game::EPEC::finalize</a>. We can also optionally tell the program to do other operations before/after finalizing, by defining an override for <a class="el" href="classGame_1_1EPEC.html#a1650a665591d7a7e982dbb11ef0e897a" title="Empty function - optionally reimplementable in derived class. ">Game::EPEC::prefinalize</a> and <a class="el" href="classGame_1_1EPEC.html#aa17713c9c874ea96c8e939ae2dc58120" title="Empty function - optionally reimplementable in derived class. ">Game::EPEC::postfinalize</a> in the derived class. </p><div class="fragment"><div class="line"><span class="comment">// Finalize</span></div><div class="line">epec.finalize();</div></div><!-- fragment --><p>One can optionally choose the algorithm to be used for solving the problem. Not setting this, chooses the default algorithm <a class="el" href="namespaceGame.html#a09f076906bd963c7e558c8f1a9506d1daef3c61c75dd7e43756d440993059dfe5">Game::EPEC::fullEnumeration</a>. </p><div class="fragment"><div class="line">epec.setAlgorithm(<a class="code" href="namespaceGame.html#a09f076906bd963c7e558c8f1a9506d1da917a285f0c43ed809f7a3016574d71a9">Game::EPECalgorithm::innerApproximation</a>);</div></div><!-- fragment --><p>Finally, the problem can be solved using </p><div class="fragment"><div class="line">epec.findNashEq();</div></div><!-- fragment --><p><b> Step 6. </b> Now we discuss methods to retrieve the solution and other details from <a class="el" href="classGame_1_1EPEC.html" title="Class to handle a Nash game between leaders of Stackelberg games. ">Game::EPEC</a>.</p>
<p>To start with, one can write the GRBModel (Gurobi model) solved in the last iteration or acquire a copy of the model. For the model writing, any extension allowed by Gurobi will work in the solver. </p><div class="fragment"><div class="line"><span class="comment">// Writes the model to a file. The model can then be loaded externally, resolved and analyzed.</span></div><div class="line">epec.writeLcpModel(<span class="stringliteral">&quot;my_model.lp&quot;</span>);  <span class="comment">// Writes to an LP file, in a human readable format</span></div><div class="line">epec.writeLcpModel(<span class="stringliteral">&quot;my_model.sol&quot;</span>); <span class="comment">// Writes to an MPS file, in a machine readable format</span></div><div class="line"><span class="comment">// Writes the solution to the same model.</span></div><div class="line"></div><div class="line">epec.writeLcpModel(<span class="stringliteral">&quot;my_model.sol&quot;</span>); <span class="comment">// Human and machine readable.</span></div></div><!-- fragment --><p>Alternatively, without saving the model, one can directly print the solution to the model. Note that an EPEC does not necessarily have a pure-strategy Nash equilibrium or a mixed-strategy Nash equilibrium. However, should it have one, we print the multiple pure strategies along with the associated probability for that strategy. These are achieved using</p>
<ul>
<li><a class="el" href="classGame_1_1EPEC.html#a94fc7b20763d6169fbd89cf9b8ab5831">Game::EPEC::getVal_Probab</a></li>
<li><a class="el" href="classGame_1_1EPEC.html#a52368c35e5cc80a176199ad56ae20908">Game::EPEC::getVal_LeadLeadPoly</a></li>
<li><a class="el" href="classGame_1_1EPEC.html#a379501dd1f80f5e80ecc788db3ca43f5">Game::EPEC::getVal_LeadFollPoly</a></li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Get the set of pure strategies that the leaders will play</span></div><div class="line"><span class="keyword">auto</span> uv_strats = epec.mixedStratPoly(0);</div><div class="line"><span class="comment">// Now print the probability of each such pure strategy and the actual strategy too.</span></div><div class="line">std::for_each(</div><div class="line">    std::begin(uv_strats), std::end(uv_strats), [&amp;epec](<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i) {</div><div class="line">      <span class="comment">// epec.getVal_Probab (a, b) gives the probability used to play b-th pure strategy by the player at position a.</span></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;With probability  &quot;</span> &lt;&lt; epec.getVal_Probab(0, i) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">      <span class="comment">// epec.getVal_LeadLeadPoly(a, b, c) gives the bth variable of a-th leader in c-th poly.</span></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; epec.getVal_LeadLeadPoly(0, 0, i) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div><div class="line">      <span class="comment">// epec.getVal_LeadFollPoly(a, b, c) gives the bth follower variable of a-th leader in c-th poly.</span></div><div class="line">                &lt;&lt; epec.getVal_LeadFollPoly(0, 0, i) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div><div class="line">                &lt;&lt; epec.getVal_LeadFollPoly(0, 1, i) &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div><div class="line">    });</div></div><!-- fragment --><p>Similarly for the x-y leader</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> xy_strats = epec.mixedStratPoly(1);</div><div class="line">std::for_each(</div><div class="line">    std::begin(xy_strats), std::end(xy_strats), [&amp;epec](<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;With probability  &quot;</span> &lt;&lt; epec.getVal_Probab(1, i) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; epec.getVal_LeadLeadPoly(1, 0, i) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div><div class="line">                &lt;&lt; epec.getVal_LeadFollPoly(1, 0, i) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div><div class="line">                &lt;&lt; epec.getVal_LeadFollPoly(1, 1, i) &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div><div class="line">    });</div></div><!-- fragment --><p>Congratulations! You have solved your first EPEC!</p>
<p>For your convenience, the entire example source code is given below. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="epecsolve_8h.html">epecsolve.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/log/core.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/log/expressions.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/log/trivial.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;gurobi_c++.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span><a class="code" href="classMy__EPEC__Prob.html">My_EPEC_Prob</a> : <span class="keyword">public</span> <a class="code" href="classGame_1_1EPEC.html#a1b8553cd89efb9951f7cec24b8c09b5f">EPEC</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="code" href="classMy__EPEC__Prob.html#aefa2a918dfceb1999c19b6d45e8a78ea">My_EPEC_Prob</a>(GRBEnv *e) : <a class="code" href="classGame_1_1EPEC.html#a1b8553cd89efb9951f7cec24b8c09b5f">EPEC</a>(e) { }</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMy__EPEC__Prob.html#ac6ab1a1debfe0fe9070d270388a18348">addLeader</a>(std::shared_ptr&lt;Game::NashGame&gt; N, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i) {</div><div class="line">    this-&gt;<a class="code" href="classGame_1_1EPEC.html#aab21e947c4fc518c305d7c35a8407f64">countries_LL</a>.push_back(N);</div><div class="line">    <a class="code" href="classMy__EPEC__Prob.html#af7de4840143d26c53b7ead389ff015e2">ends</a>[i] = N-&gt;getNprimals() + N-&gt;getNleaderVars();</div><div class="line">    this-&gt;<a class="code" href="classGame_1_1EPEC.html#a618f3df2c40a9d456f9ceaf00802967c">LocEnds</a>.push_back(&amp;<a class="code" href="classMy__EPEC__Prob.html#af7de4840143d26c53b7ead389ff015e2">ends</a>[i]);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classMy__EPEC__Prob.html#af7de4840143d26c53b7ead389ff015e2">ends</a>[2];</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMy__EPEC__Prob.html#a86c301b16593d38339cbbd4a8cf68493">updateLocs</a>()<span class="keyword"> override </span>{</div><div class="line">    ends[0] = this-&gt;<a class="code" href="classGame_1_1EPEC.html#a0ae85cba915c2cfcdfd8b141e2daffbe">convexHullVariables</a>.at(0) + 3;</div><div class="line">    ends[1] = this-&gt;<a class="code" href="classGame_1_1EPEC.html#a0ae85cba915c2cfcdfd8b141e2daffbe">convexHullVariables</a>.at(1) + 3;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMy__EPEC__Prob.html#a579c1f0e091a02782266afcfa82c3604">make_obj_leader</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i,</div><div class="line">                       <a class="code" href="structGame_1_1QP__objective.html">Game::QP_objective</a> &amp;QP_obj)<span class="keyword"> override </span>{</div><div class="line">    QP_obj.<a class="code" href="structGame_1_1QP__objective.html#a18c0eadf5706175777a16f2d9349f539">Q</a>.zeros(3, 3);</div><div class="line">    QP_obj.<a class="code" href="structGame_1_1QP__objective.html#add2d1d53d0a2b14e047b5ff87fe86859">C</a>.zeros(3, 3);</div><div class="line">    QP_obj.<a class="code" href="structGame_1_1QP__objective.html#aace376a44fea80a8fbe5eb712e14b3e5">c</a>.zeros(3);</div><div class="line">    <span class="keywordflow">switch</span> (i) {</div><div class="line">    <span class="keywordflow">case</span> 0: <span class="comment">// uv_leader&#39;s objective</span></div><div class="line">      QP_obj.<a class="code" href="structGame_1_1QP__objective.html#add2d1d53d0a2b14e047b5ff87fe86859">C</a>(1, 0) = 1;</div><div class="line">      QP_obj.<a class="code" href="structGame_1_1QP__objective.html#aace376a44fea80a8fbe5eb712e14b3e5">c</a>(0) = 1;</div><div class="line">      QP_obj.<a class="code" href="structGame_1_1QP__objective.html#aace376a44fea80a8fbe5eb712e14b3e5">c</a>(2) = -1;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> 1: <span class="comment">// xy_leader&#39;s objective</span></div><div class="line">      QP_obj.<a class="code" href="structGame_1_1QP__objective.html#add2d1d53d0a2b14e047b5ff87fe86859">C</a>(1, 2) = 1;</div><div class="line">      QP_obj.<a class="code" href="structGame_1_1QP__objective.html#aace376a44fea80a8fbe5eb712e14b3e5">c</a>(0) = 1;</div><div class="line">      QP_obj.<a class="code" href="structGame_1_1QP__objective.html#aace376a44fea80a8fbe5eb712e14b3e5">c</a>(2) = 1;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">      <span class="keywordflow">throw</span> std::string(<span class="stringliteral">&quot;Invalid make_obj_leader&quot;</span>);</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">std::shared_ptr&lt;Game::NashGame&gt; <a class="code" href="example_8cpp.html#a8c14f00b24da0f390b1fd45aaae2fdda">uv_leader</a>(GRBEnv *env) {</div><div class="line">  <span class="comment">// 2 variable and 2 constraints</span></div><div class="line">  arma::sp_mat Q(2, 2), C(2, 1), A(2, 1), B(2, 2);</div><div class="line">  arma::vec c(2, arma::fill::zeros);</div><div class="line">  arma::vec b(2, arma::fill::zeros);</div><div class="line">  <span class="comment">// Q remains as 0</span></div><div class="line">  <span class="comment">// C remains as 0</span></div><div class="line">  <span class="comment">// c</span></div><div class="line">  c(0) = -1;</div><div class="line">  c(1) = 1;</div><div class="line">  <span class="comment">// A</span></div><div class="line">  A(0, 0) = -1;</div><div class="line">  A(1, 0) = 1;</div><div class="line">  <span class="comment">// B</span></div><div class="line">  B(0, 0) = 2;</div><div class="line">  B(0, 1) = 1;</div><div class="line">  B(1, 0) = 1;</div><div class="line">  B(1, 1) = -2;</div><div class="line">  <span class="keyword">auto</span> foll = std::make_shared&lt;Game::QP_Param&gt;(Q, C, A, B, c, b, <a class="code" href="classGame_1_1EPEC.html#a5c9d2ad673948e23b72af16174335386">env</a>);</div><div class="line"></div><div class="line">  <span class="comment">// Lower level Market clearing constraints - empty</span></div><div class="line">  arma::sp_mat MC(0, 3);</div><div class="line">  arma::vec MCRHS(0, arma::fill::zeros);</div><div class="line"></div><div class="line">  arma::sp_mat LeadCons(1, 3);</div><div class="line">  arma::vec LeadRHS(1);</div><div class="line">  LeadCons(0, 0) = 1;</div><div class="line">  LeadCons(0, 1) = 1;</div><div class="line">  LeadCons(0, 2) = 1;</div><div class="line">  LeadRHS(0) = 5;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> N = std::make_shared&lt;Game::NashGame&gt;(</div><div class="line">      <a class="code" href="classGame_1_1EPEC.html#a5c9d2ad673948e23b72af16174335386">env</a>, std::vector&lt;std::shared_ptr&lt;Game::QP_Param&gt;&gt;{foll}, MC, MCRHS, 1,</div><div class="line">      LeadCons, LeadRHS);</div><div class="line">  <span class="keywordflow">return</span> N;</div><div class="line">}</div><div class="line"></div><div class="line">std::shared_ptr&lt;Game::NashGame&gt; <a class="code" href="example_8cpp.html#ace379e899ab4b800e81aadcc80d42922">xy_leader</a>(GRBEnv *env) {</div><div class="line">  <span class="comment">// 2 variable and 2 constraints</span></div><div class="line">  arma::sp_mat Q(2, 2), C(2, 1), A(2, 1), B(2, 2);</div><div class="line">  arma::vec c(2, arma::fill::zeros);</div><div class="line">  arma::vec b(2, arma::fill::zeros);</div><div class="line">  <span class="comment">// Q remains as 0</span></div><div class="line">  <span class="comment">// C remains as 0</span></div><div class="line">  <span class="comment">// c</span></div><div class="line">  c(0) = 1;</div><div class="line">  c(1) = -1;</div><div class="line">  <span class="comment">// A</span></div><div class="line">  A(0, 0) = 1;</div><div class="line">  A(1, 0) = -1;</div><div class="line">  <span class="comment">// B</span></div><div class="line">  B(0, 0) = -1;</div><div class="line">  B(0, 1) = 1;</div><div class="line">  B(1, 0) = -1;</div><div class="line">  B(1, 1) = 1;</div><div class="line">  <span class="comment">// b</span></div><div class="line">  b(0) = 5;</div><div class="line">  b(1) = -3;</div><div class="line">  <span class="keyword">auto</span> foll = std::make_shared&lt;Game::QP_Param&gt;(Q, C, A, B, c, b, <a class="code" href="classGame_1_1EPEC.html#a5c9d2ad673948e23b72af16174335386">env</a>);</div><div class="line"></div><div class="line">  <span class="comment">// Lower level Market clearing constraints - empty</span></div><div class="line">  arma::sp_mat MC(0, 3);</div><div class="line">  arma::vec MCRHS(0, arma::fill::zeros);</div><div class="line"></div><div class="line">  arma::sp_mat LeadCons(2, 3);</div><div class="line">  arma::vec LeadRHS(2);</div><div class="line">  LeadCons(0, 0) = 1;</div><div class="line">  LeadCons(0, 1) = 1;</div><div class="line">  LeadCons(0, 2) = 1;</div><div class="line">  LeadRHS(0) = 7;</div><div class="line">  <span class="comment">// Comment the following four lines for another example ;)</span></div><div class="line">  LeadCons(1, 0) = -1;</div><div class="line">  LeadCons(1, 1) = 1;</div><div class="line">  LeadCons(1, 2) = 0;</div><div class="line">  LeadRHS(1) = 0;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> N = std::make_shared&lt;Game::NashGame&gt;(</div><div class="line">      <a class="code" href="classGame_1_1EPEC.html#a5c9d2ad673948e23b72af16174335386">env</a>, std::vector&lt;std::shared_ptr&lt;Game::QP_Param&gt;&gt;{foll}, MC, MCRHS, 1,</div><div class="line">      LeadCons, LeadRHS);</div><div class="line">  <span class="keywordflow">return</span> N;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="src_2EPEC_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">  GRBEnv <a class="code" href="classGame_1_1EPEC.html#a5c9d2ad673948e23b72af16174335386">env</a>;</div><div class="line">  boost::log::core::get()-&gt;set_filter(boost::log::trivial::severity &gt;=</div><div class="line">  boost::log::trivial::warning);</div><div class="line">  <a class="code" href="classMy__EPEC__Prob.html">My_EPEC_Prob</a> epec(&amp;env);</div><div class="line">  <span class="comment">// Adding uv_leader</span></div><div class="line">  <span class="keyword">auto</span> uv_lead = <a class="code" href="example_8cpp.html#a8c14f00b24da0f390b1fd45aaae2fdda">uv_leader</a>(&amp;env);</div><div class="line">  epec.addLeader(uv_lead, 0);</div><div class="line">  <span class="comment">// Adding xy_leader</span></div><div class="line">  <span class="keyword">auto</span> xy_lead = <a class="code" href="example_8cpp.html#ace379e899ab4b800e81aadcc80d42922">xy_leader</a>(&amp;env);</div><div class="line">  epec.addLeader(xy_lead, 1);</div><div class="line">  <span class="comment">// Finalize</span></div><div class="line">  epec.finalize();</div><div class="line">  epec.setAlgorithm(<a class="code" href="namespaceGame.html#a09f076906bd963c7e558c8f1a9506d1da917a285f0c43ed809f7a3016574d71a9">Game::EPECalgorithm::innerApproximation</a>);</div><div class="line">  <span class="comment">// Solve</span></div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    epec.findNashEq();</div><div class="line">  } <span class="keywordflow">catch</span> (std::string &amp;s) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error caught: &quot;</span> &lt;&lt; s &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    <span class="keywordflow">throw</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\nUV LEADER\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;u: &quot;</span> &lt;&lt; epec.getVal_LeadLead(0, 0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;v_1: &quot;</span> &lt;&lt; epec.getVal_LeadFoll(0, 0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;v_2: &quot;</span> &lt;&lt; epec.getVal_LeadFoll(0, 1) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">  <span class="keyword">auto</span> uv_strats = epec.mixedStratPoly(0);</div><div class="line">  std::for_each(</div><div class="line">      std::begin(uv_strats), std::end(uv_strats), [&amp;epec](<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;With probability  &quot;</span> &lt;&lt; epec.getVal_Probab(0, i) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; epec.getVal_LeadLeadPoly(0, 0, i) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div><div class="line">                  &lt;&lt; epec.getVal_LeadFollPoly(0, 0, i) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div><div class="line">                  &lt;&lt; epec.getVal_LeadFollPoly(0, 1, i) &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div><div class="line">      });</div><div class="line">  std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\nXY LEADER\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;x: &quot;</span> &lt;&lt; epec.getVal_LeadLead(1, 0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;y_1: &quot;</span> &lt;&lt; epec.getVal_LeadFoll(1, 0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;y_2: &quot;</span> &lt;&lt; epec.getVal_LeadFoll(1, 1) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">  <span class="keyword">auto</span> xy_strats = epec.mixedStratPoly(1);</div><div class="line">  std::for_each(</div><div class="line">      std::begin(xy_strats), std::end(xy_strats), [&amp;epec](<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;With probability  &quot;</span> &lt;&lt; epec.getVal_Probab(1, i) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; epec.getVal_LeadLeadPoly(1, 0, i) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div><div class="line">                  &lt;&lt; epec.getVal_LeadFollPoly(1, 0, i) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div><div class="line">                  &lt;&lt; epec.getVal_LeadFollPoly(1, 1, i) &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div><div class="line">      });</div><div class="line">  std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
